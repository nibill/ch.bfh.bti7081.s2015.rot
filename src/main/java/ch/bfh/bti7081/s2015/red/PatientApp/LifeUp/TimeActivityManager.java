package ch.bfh.bti7081.s2015.red.PatientApp.LifeUp;import java.util.ArrayList;import java.util.Date;import ch.bfh.bti7081.s2015.red.PatientApp.LifeUp.ActivityState;import ch.bfh.bti7081.s2015.red.PatientApp.Model.Activity;import ch.bfh.bti7081.s2015.red.PatientApp.Model.GpsActivity;/** * This class handles all time relevant states, so they * are going to be FinishedInTime or FinishedTooLate or Failed, * depending if the patient has done the Activities in their * soft/hard time limit or not. * @author Stefan Tanner * */		public class TimeActivityManager implements Runnable {		volatile private static TimeActivityManager instance = null;	volatile private ArrayList<Activity> activites = new ArrayList<Activity>();	volatile private Activity currentActivity;		/**	 * Returns the instance of the TimeActivityManager.	 *  	 * @return	TimeActivityManager	returns current TimeActivityManager	 * @see		ActivityState	 */		public static TimeActivityManager getInstance() {		if (instance == null) {			instance = new TimeActivityManager();		}		return instance;	}	private TimeActivityManager() {		(new Thread(this)).start();	}		/**	 * Sets the TimeActivityManager to the current Activity.	 *  	 * @param	activity	sets the interal Activity to the current, so futher calls be affected to the choosen one	 * @see		Activity	 */		public void chooseActivity(Activity activity) {  		for (int i = 0; i < activites.size(); i++) {			if ( activity.getId().equals(activites.get(i).getId()) ) {				currentActivity = activites.get(i);			}		}			}	/**	 * Does force the current Activity to change it's state to the next state.	 */		public void nextState() {		currentActivity.nextState();	}	/**	 * Add's an Activity to the TimeActivityManager	 *  	 * @param	activity	which has to be added to the Thread	 * @see		Activity	 */		public void addActivity(Activity activity) { 		boolean existing = false;		for (int i = 0; i < activites.size(); i++) {			if ( activity.getId().equals(activites.get(i).getId()) ) {				currentActivity = activites.get(i);				existing = true;			}		}		if ( !existing ) {			activites.add(activity);		}			}		private void removeActivity(Activity activity) {		activites.remove(activites.indexOf(activity));	}		/**	 * Starts the Thread and check's in a 5 seconds interval if an Activity goes to the specific state depending on soft/hard time limit.	 */		@Override	public void run() {		controlActivitesScheduled();	}		/**	 * Iterates through every in the Thread registrated Activity and check, if a state change is needed	 */		private void controlActivitesScheduled() {		try {						Thread.sleep(5000);			Date now = new Date();  						ArrayList<Activity> removeLater = new ArrayList<Activity>();						for (int i = 0; i < activites.size(); i++) {				Activity registratedActivity = activites.get(i);  				int hardTimeLimitRest = (int) ((registratedActivity.getHardTimeLimit().getTime()-now.getTime()) / 1000); 												if ( hardTimeLimitRest < 0 && registratedActivity.getStateName().equals("InProgress") ) {					registratedActivity.nextState(); 				}								if ( !registratedActivity.getStateName().equals("TimeActivityReady") && !registratedActivity.getStateName().equals("InProgress")  ) {					removeLater.add(registratedActivity);				}							}						for ( int i = 0; i < removeLater.size(); i++ ) {				removeActivity(removeLater.get(i));			}								} catch (InterruptedException e) {			e.printStackTrace();		}		controlActivitesScheduled();	}		/**	 * Sets the referencing ActivityState to it's activity	 *   	 * @param	activityState	the calling ActivityState - in most case, use 'this'	 * @see		Activity	 */		public void setActivityState(ActivityState activityState) {		currentActivity.setActivityState(activityState);		activites.set(activites.indexOf(currentActivity), currentActivity);	}	/**	 * Returns the current Activity	 *   	 * @return	Activity	the current choosen Activity from the TimeActivityManager	 * @see		Activity	 */		public Activity getActivity() {		return activites.get(getActivityIndex());	}		private int getActivityIndex() {		return activites.indexOf(currentActivity);	}}